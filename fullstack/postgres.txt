* install 
	* pip3 install flask 
	* pip3 install flask-sqlalchemy
	* pip3 install psycopg2-binary

* Create user
	$ su postgres
	$ psql
	postgres=# alter user athleticu createdb;
	ALTER ROLE
	
* psql is a client 
	\l - list \dt - data tables 
	\d table_name list contents
	\q quit table_name

* 

* SQLAlchemy

	SQLAlchemy is the most popular open-source library for working with relational databases from Python.
	It is one type of ORM library, AKA an Object-Relational Mapping library, which provides an interface for using object oriented programming to interact with a database.
	Other ORM libraries that exist across other languages include popular choices like javascript libraries Sequelize and Bookshelf.js for NodeJS applications, the ruby library ActiveRecord, which is used inside Ruby on Rails, and CakePHP for applications written on PHP, amongst many other such ORMs.

	Note on ORMs: are they a "best practice"?
	Using an ORM to interact with your database is simply one of many valid approaches for how you can add additional layers of abstraction to your web application to interact with a database more easily. There are other kinds of query builder libraries you can use that are between talking to a database directly (with a database driver library like pyscopg2), and using an ORM. An ORM is considered to be the highest level of abstraction you can add to a web application for database management. Query Builder libraries are somewhere in the middle. There are many mixed opinions about whether ORMs are a best practice approach in all cases, such as this opinion on "Why you should avoid ORMs".

	Thankfully, SQLAlchemy happens to offer multiple levels of abstraction you can prefer, between the database driver and the ORM, so you can customize the development of your web application to your own liking. The many granular levels of abstraction that SQLAlchemy offers, which we will touch upon in the next lesson, is one of the reasons that has led to its widespread popularity and diverse ways of using the library and approaching your database programming.

	SQLAlchemy:

		Features function-based query construction: allows SQL clauses to be built via Python functions and expressions.

		Avoid writing raw SQL. It generates SQL and Python code for you to access tables, which leads to less database-related overhead in terms of the volume of code you need to write overall to interact with your models.

		Moreover, you can avoid sending SQL to the database on every call. The SQLAlchemy ORM library features automatic caching, caching collections and references between objects once initially loaded.


	 SQLAlchemy's Layers of Abstraction
		SQLAlchemy is broken down into various layers of abstraction. Let's go through each layer in depth.

		Without SQLAlchemy, we'd only use a DBAPI to establish connections and execute SQL statements. Simple, but not scalable as complexity grows.
		SQLAlchemy offers several layers of abstraction and convenient tools for interacting with a database.
		SQLAlchemy vs psycopg2
		SQLAlchemy generates SQL statements
		psycopg2 directly sends SQL statements to the database.
		SQLAlchemy depends on psycopg2 or other database drivers to communicate with the database, under the hood.
		SQLALchemy lets you traverse through all 3 layers of abstraction to interact with your database.
		Can stay on the ORM level
		Can dive into database operations to run customized SQL code specific to the database, on the Expressions level.
		Can write raw SQL to execute, when needed, on the Engine level.
		Can more simply use psycopg2 in this case
		Good Design Practice (Opinion)
		Here's my opinion on interacting with databases using good design practice.

		Keep your code Pythonic. Work in classes and objects as much as possible.
		Makes switching to a different backend easy in the feature.
		Avoid writing raw SQL until absolutely necessary
		In the next series of videos, we'll go over every layer of abstraction in SQLAlchemy and what they offer.


		Layers of SQLAlchemy
			DBAPI
			The Dialect
			The Connection Pool
			The Engine
			SQL Expressions
			SQLAlchemy ORM (optional)
	
	  * connection poolâ€¦


			Handles dropped connections

			Avoids doing very many small calls to the DB

			Avoids opening and closing connections for every data change

	  * The Engine
		1 of 3 main layers for how you may choose to interact with the database.
		Is the lowest level layer of interacting with the database, and is much like using the DBAPI directly. Very similar to using psycopg2, managing a connection directly.
		Moreover,

		The Engine in SQLAlchemy refers to both itself, the Dialect and the Connection Pool, which all work together to interface with our database.
		A connection pool gets automatically created when we create a SQLAlchemy engine.

		Instead of sending raw SQL (using the Engine), we can compose python objects to compose SQL expressions, instead.
		SQL Expressions still involves using and knowing SQL to interact with the database.
		
		
		
	* SQLAlchemy ORM
			Lets you compose SQL expressions by mapping python classes of objects to tables in the database
			Is the highest layer of abstraction in SQLALchemy.
			Wraps the SQL Expressions and Engine to work together to interact with the database
			Will be used in this course, so we can know how to use ORM libraries in general.
			Moreover, SQLAlchemy is split into two libraries:

			SQLAlchemy Core
			SQLAlchemy ORM (Object Relational Mapping library). SQLALchemy ORM is offered as an optional library, so you don't have to use the ORM in order to use the rest of SQLAlchemy.
			The ORM uses the Core library inside
			The ORM lets you map from the database schema to the application's Python objects
			The ORM persists objects into corresponding database tables
			
	* table maps to classes
	  table record maps to objects
	  table columns map to attributes
	  
	* 'postgresql://myusername:mypassword@localhost:5432/mydatabase'
	
	* Given an instance of the SQLAlchemy class from Flask-SQLAlchemy,

		db = SQLAlchemy(app)
		db is an interface for interacting with our database
		db.Model lets us create and manipulate data models
		db.session lets us create and manipulate database transactions
		
		Declaring classes
		class MyModel(db.Model) will inherit from db.Model
		By inheriting from db.Model, we map from our classes to tables via SQLAlchemy ORM
		Defining columns
		Within our class, we declare attributes equal to db.Column(...)
		db.Column takes <datatype>, <primary_key?>, <constraint?>, <default?>
		Table naming
		By default, SQLAlchemy will pick the name of the table for you, setting it equal to the lower-case version of your class's name. Otherwise, we set the name of the table using __tablename__ = 'my_custom_table_name'.
		
		
	* 
	