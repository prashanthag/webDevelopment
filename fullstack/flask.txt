	sqlalchemy cheat sheet 
*  https://github.com/crazyguitar/pysheeet/blob/master/docs/notes/python-sqlalchemy.rst#set-a-database-url

	person = Person(name='Amy')
	db.session.add(person)
	db.session.commit()
	
	https://github.com/crazyguitar/pysheeet/blob/master/docs/notes/python-sqlalchemy.rst#set-a-database-url
	
	
* 	Queries 
	MyModel.order_by(MyModel.created_at)
	MyModel.order_by(db.desc(MyModel.created_at))
	  To order the results by a given attribute. Use db.desc to order in descending order.
	  
	Join
	Driver.query.join('vehicles')
	Query has a method join(<table_name>) for joining one model to another table.

	print(Person.query.filter(Person.name.like('%my%')).all());
	
* SQLAlchemy Object Lifecycle	
	Within a session, we create transactions every time we want to commit work to the database.
	Proposed changes are not immediately committed to the database and instead go through stages to allow for undos.
	The ability to undo is allowed via db.session.rollback()
	Stages:
	Transient: an object exists, it was defined.

	user1 = User(name='Amy')
	...but not attached to a session (yet).

	Pending: an object was attached to a session. "Undo" becomes available via db.session.rollback(). Waits for a flush to happen

	Flushed: about ready to be committed to the database, translating actions into SQL command statements for the engine.

	Committed: manually called for a change to persist to the database (permanently); session's transaction is cleared for a new set of changes.
	
	* Building CRUD 
	
		todoapp/app.py
		from flask import Flask, render_template
		from flask_sqlalchemy import SQLAlchemy

		app = Flask(__name__)
		app.config['SQLALCHEMY_DATABASE_URI'] = 'postgres://udacitystudios@localhost:5432/todoapp'
		db = SQLAlchemy(app)

		class Todo(db.Model):
		  __tablename__ = 'todos'
		  id = db.Column(db.Integer, primary_key=True)
		  description = db.Column(db.String(), nullable=False)

		  def __repr__(self):
			return f'<Todo {self.id} {self.description}>'

		db.create_all()

		@app.route('/')
		def index():
		  return render_template('index.html', data=Todo.query.all())
		todoapp/templates/index.html
		<html>
		  <head>
			<title>Todo App</title>
		  </head>
		  <body>
			<ul>
			  {% for d in data %}
			  <li>{{ d.description }}</li>
			  {% endfor %}
			</ul>
		  </body>
		</html>
		terminal commands executed
		$ create todoapp
		$ FLASK_APP=app.py FLASK_DEBUG=true flask run
		psql todoapp
		>>> \dt
		>>> \d todos
		>>> INSERT INTO todos (description) VALUES ('Do a thing 1');
		>>> INSERT INTO todos (description) VALUES ('Do a thing 2');
		>>> INSERT INTO todos (description) VALUES ('Do a thing 3');
		>>> INSERT INTO todos (description) VALUES ('Do a thing 4');
		>>> select * from todos;
		
		
*    MVC stands for Model-View-Controller, a common pattern for architecting web applications
		Describes the 3 layers of the application we are developing
		Layers
		Models: manage data and business logic for us. What happens inside models and database, capturing logical relationships and properties across the web app objects
		Views :handles display and representation logic. What the user sees (HTML, CSS, JS from the user's perspective)
		Controllers: routes commands to the models and views, containing control logic. Control how commands are sent to models and views, and how models and views wound up interacting with each other.
				
		Creating, updating, and deleting information from a database requires handling user input on what is being created/updated/deleted. This will be the focus of the rest of this series.
		MVC Development: How we'd add Create To-Do item functionality
		On the view: implement an HTML form
		On the controller: retrieve the user's input, and manipulate models
		On the models: create a record in our database, and return the newly created to-do item to the controller
		On the controller: take the newly created to-do item, and decide how to update the view with it.
		What we'll learn in order
		How we accept and get user data in the context of a Flask app
		Send data in controllers using database sessions in a controller
		Manipulating models adding records in SQLAlchemy Models
		Direct how the view should update within the controller and views
		
		
* AJAX
		Data request are either synchronous or async (asynchronous)
		Async data requests are requests that get sent to the server and back to the client without a page refresh.
		Async requests (AJAX requests) use one of two methods:
		XMLHttpRequest
		Fetch (modern way)
		
				var xhttp = new XMLHttpRequest();

				description = document.getElementById("description").value;

				xhttp.open("GET", "/todos/create?description=" + description);

				xhttp.send();

				xhttp.onreadystatechange = function() {
					if (this.readyState === 4 && this.status === 200) { 
					  // on successful response
					  console.log(xhttp.responseText);
					}
				};
				
		Fetch is another window object that lets you send HTTP requests
		fetch(<url-route>, <object of request parameters>)
					
			 fetch('/my/request', {
			  method: 'POST',
			  body: JSON.stringify({
				'description': 'some description here'
			  }),
			  headers: {
				'Content-Type': 'application/json'
			  }
			});


		 import sys

		 try:
		   todo = Todo(description=description)
		   db.session.add(todo)
		   db.session.commit()
		 except:
		   db.session.rollback()
		   error=True
		   print(sys.exc_info())
		 finally:
		   db.session.close()
